// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertRunTriggerSQL = `INSERT INTO run_triggers (
    run_trigger_id,
    created_at,
    sourceable_id,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertRunTriggerParams struct {
	RunTriggerID pgtype.Text        `json:"run_trigger_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	SourceableID pgtype.Text        `json:"sourceable_id"`
	WorkspaceID  pgtype.Text        `json:"workspace_id"`
}

// InsertRunTrigger implements Querier.InsertRunTrigger.
func (q *DBQuerier) InsertRunTrigger(ctx context.Context, params InsertRunTriggerParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRunTrigger")
	cmdTag, err := q.conn.Exec(ctx, insertRunTriggerSQL, params.RunTriggerID, params.CreatedAt, params.SourceableID, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertRunTrigger: %w", err)
	}
	return cmdTag, err
}

// InsertRunTriggerBatch implements Querier.InsertRunTriggerBatch.
func (q *DBQuerier) InsertRunTriggerBatch(batch genericBatch, params InsertRunTriggerParams) {
	batch.Queue(insertRunTriggerSQL, params.RunTriggerID, params.CreatedAt, params.SourceableID, params.WorkspaceID)
}

// InsertRunTriggerScan implements Querier.InsertRunTriggerScan.
func (q *DBQuerier) InsertRunTriggerScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertRunTriggerBatch: %w", err)
	}
	return cmdTag, err
}

const findRunTriggersBySourceableIDSQL = `SELECT
    run_triggers.run_trigger_id,
    run_triggers.created_at,
    run_triggers.sourceable_id,
    run_triggers.workspace_id
FROM run_triggers
WHERE run_triggers.sourceable_id = $1
ORDER BY run_triggers.created_at DESC
;`

type FindRunTriggersBySourceableIDRow struct {
	RunTriggerID pgtype.Text        `json:"run_trigger_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	SourceableID pgtype.Text        `json:"sourceable_id"`
	WorkspaceID  pgtype.Text        `json:"workspace_id"`
}

// FindRunTriggersBySourceableID implements Querier.FindRunTriggersBySourceableID.
func (q *DBQuerier) FindRunTriggersBySourceableID(ctx context.Context, sourceableID pgtype.Text) ([]FindRunTriggersBySourceableIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunTriggersBySourceableID")
	rows, err := q.conn.Query(ctx, findRunTriggersBySourceableIDSQL, sourceableID)
	if err != nil {
		return nil, fmt.Errorf("query FindRunTriggersBySourceableID: %w", err)
	}
	defer rows.Close()
	items := []FindRunTriggersBySourceableIDRow{}
	for rows.Next() {
		var item FindRunTriggersBySourceableIDRow
		if err := rows.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindRunTriggersBySourceableID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunTriggersBySourceableID rows: %w", err)
	}
	return items, err
}

// FindRunTriggersBySourceableIDBatch implements Querier.FindRunTriggersBySourceableIDBatch.
func (q *DBQuerier) FindRunTriggersBySourceableIDBatch(batch genericBatch, sourceableID pgtype.Text) {
	batch.Queue(findRunTriggersBySourceableIDSQL, sourceableID)
}

// FindRunTriggersBySourceableIDScan implements Querier.FindRunTriggersBySourceableIDScan.
func (q *DBQuerier) FindRunTriggersBySourceableIDScan(results pgx.BatchResults) ([]FindRunTriggersBySourceableIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRunTriggersBySourceableIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRunTriggersBySourceableIDRow{}
	for rows.Next() {
		var item FindRunTriggersBySourceableIDRow
		if err := rows.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindRunTriggersBySourceableIDBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunTriggersBySourceableIDBatch rows: %w", err)
	}
	return items, err
}

const findRunTriggersByWorkspaceIDSQL = `SELECT
    run_triggers.run_trigger_id,
    run_triggers.created_at,
    run_triggers.sourceable_id,
    run_triggers.workspace_id
FROM run_triggers
WHERE run_triggers.workspace_id = $1
ORDER BY run_triggers.created_at DESC
;`

type FindRunTriggersByWorkspaceIDRow struct {
	RunTriggerID pgtype.Text        `json:"run_trigger_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	SourceableID pgtype.Text        `json:"sourceable_id"`
	WorkspaceID  pgtype.Text        `json:"workspace_id"`
}

// FindRunTriggersByWorkspaceID implements Querier.FindRunTriggersByWorkspaceID.
func (q *DBQuerier) FindRunTriggersByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindRunTriggersByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunTriggersByWorkspaceID")
	rows, err := q.conn.Query(ctx, findRunTriggersByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindRunTriggersByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindRunTriggersByWorkspaceIDRow{}
	for rows.Next() {
		var item FindRunTriggersByWorkspaceIDRow
		if err := rows.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindRunTriggersByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunTriggersByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindRunTriggersByWorkspaceIDBatch implements Querier.FindRunTriggersByWorkspaceIDBatch.
func (q *DBQuerier) FindRunTriggersByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findRunTriggersByWorkspaceIDSQL, workspaceID)
}

// FindRunTriggersByWorkspaceIDScan implements Querier.FindRunTriggersByWorkspaceIDScan.
func (q *DBQuerier) FindRunTriggersByWorkspaceIDScan(results pgx.BatchResults) ([]FindRunTriggersByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRunTriggersByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRunTriggersByWorkspaceIDRow{}
	for rows.Next() {
		var item FindRunTriggersByWorkspaceIDRow
		if err := rows.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindRunTriggersByWorkspaceIDBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunTriggersByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const findRunTriggerByIDSQL = `SELECT
    run_triggers.run_trigger_id,
    run_triggers.created_at,
    run_triggers.sourceable_id,
    run_triggers.workspace_id
FROM run_triggers
WHERE run_triggers.run_trigger_id = $1
;`

type FindRunTriggerByIDRow struct {
	RunTriggerID pgtype.Text        `json:"run_trigger_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	SourceableID pgtype.Text        `json:"sourceable_id"`
	WorkspaceID  pgtype.Text        `json:"workspace_id"`
}

// FindRunTriggerByID implements Querier.FindRunTriggerByID.
func (q *DBQuerier) FindRunTriggerByID(ctx context.Context, runTriggerID pgtype.Text) (FindRunTriggerByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunTriggerByID")
	row := q.conn.QueryRow(ctx, findRunTriggerByIDSQL, runTriggerID)
	var item FindRunTriggerByIDRow
	if err := row.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query FindRunTriggerByID: %w", err)
	}
	return item, nil
}

// FindRunTriggerByIDBatch implements Querier.FindRunTriggerByIDBatch.
func (q *DBQuerier) FindRunTriggerByIDBatch(batch genericBatch, runTriggerID pgtype.Text) {
	batch.Queue(findRunTriggerByIDSQL, runTriggerID)
}

// FindRunTriggerByIDScan implements Querier.FindRunTriggerByIDScan.
func (q *DBQuerier) FindRunTriggerByIDScan(results pgx.BatchResults) (FindRunTriggerByIDRow, error) {
	row := results.QueryRow()
	var item FindRunTriggerByIDRow
	if err := row.Scan(&item.RunTriggerID, &item.CreatedAt, &item.SourceableID, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan FindRunTriggerByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteRunTriggerByIDSQL = `DELETE
FROM run_triggers
WHERE run_trigger_id = $1
RETURNING run_trigger_id
;`

// DeleteRunTriggerByID implements Querier.DeleteRunTriggerByID.
func (q *DBQuerier) DeleteRunTriggerByID(ctx context.Context, runTriggerID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteRunTriggerByID")
	row := q.conn.QueryRow(ctx, deleteRunTriggerByIDSQL, runTriggerID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteRunTriggerByID: %w", err)
	}
	return item, nil
}

// DeleteRunTriggerByIDBatch implements Querier.DeleteRunTriggerByIDBatch.
func (q *DBQuerier) DeleteRunTriggerByIDBatch(batch genericBatch, runTriggerID pgtype.Text) {
	batch.Queue(deleteRunTriggerByIDSQL, runTriggerID)
}

// DeleteRunTriggerByIDScan implements Querier.DeleteRunTriggerByIDScan.
func (q *DBQuerier) DeleteRunTriggerByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteRunTriggerByIDBatch row: %w", err)
	}
	return item, nil
}
